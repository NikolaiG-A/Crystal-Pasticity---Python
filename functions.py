import numpy as np
from classes import *

#def def_grad(p,U,T):
#    ############## input ##############
#    # p - points of the mesh
#    # U - displacements
#    # T - connectivity list
#    
#    ############## output ##############
#    # F - list of class 'deform_grad' (see classes.py)
#    
#    ###### separate u - horizontal, and v - vertical displacements
#    if U.shape[0]==2*p.shape[0]:
#        u=U[::2]
#        v=U[1::2]
#    else:
#        u=U[:,0]
#        v=U[:,1]
#    ###### create function to perform the Lagrange reduction
#    def basis_reduction(E):
#        ### basis reduction
#        if np.linalg.norm(E[:,0])>np.linalg.norm(E[:,1]):
#            E = E[:,[1,0]]
#        if np.dot(E[:,0],E[:,1])<0:
#            E[:,1] = - E[:,1]
#        if np.linalg.norm(E[:,1]-E[:,0])<np.linalg.norm(E[:,1]):
#            E = basis_reduction(np.array([E[:,0],E[:,1]-E[:,0]]).T);
#        return(E)
#    ###### create an empty list of deformation gradient for each element
#    F = []
#    for i in range(T.shape[0]):
#        ### get nodes inside an element
#        nodes=T[i,:]
#        ### calculate element area
#        Pe=np.transpose(p[nodes,:])
#        A=0.5*np.linalg.det(np.array([[1,1,1],p[nodes,0],p[nodes,1]]))
#        ### inverse transform of a current element to a reference one
#        invJ=0.5/A*np.array([[(p[nodes[2],1]-p[nodes[0],1]),-(p[nodes[2],0]-p[nodes[0],0])], [-(p[nodes[1],1]-p[nodes[0],1]),(p[nodes[1],0]-p[nodes[0],0])]])
#        ### matrix of dispacement gradients   
#        def_u=np.array([[u[nodes[1]]-u[nodes[0]],u[nodes[2]]-u[nodes[0]]],[v[nodes[1]]-v[nodes[0]],v[nodes[2]]-v[nodes[0]]]])
#        ### calculate the deformation gradient
#        F_temp=np.eye(2)+def_u.dot(invJ);
#        ### the matrix of derivatives comes from differentiation with respect
#        ### to coordinates of the basic triangular by columns
#        derF_1=np.array([-1.0*(invJ[0,0]+invJ[1,0]),0,-1.0*(invJ[0,1]+invJ[1,1]),0]) ### dF/du_1
#        derF_2=np.array([0,-1.0*(invJ[0,0]+invJ[1,0]),0,-1.0*(invJ[0,1]+invJ[1,1])]) ### dF/dv_1    
#        derF_3=np.array([invJ[0,0],0,invJ[0,1],0]) ### dF/du_2
#        derF_4=np.array([0,invJ[0,0],0,invJ[0,1]]) ### dF/dv_2  
#        derF_5=np.array([invJ[1,0],0,invJ[1,1],0]) ### dF/du_3
#        derF_6=np.array([0,invJ[1,0],0,invJ[1,1]]) ### dF/dv_3
#        ### save the final result
#        dF=np.array([derF_1,derF_2,derF_3,derF_4,derF_5,derF_6]).T
#        ### perform the Lagrange reduction
#        F_r=basis_reduction(np.copy(F_temp))
#        m=np.linalg.inv(F_temp).dot(F_r)
#        F.append(deform_grad(F_temp,dF,A,F_r,m))
#    return(F)
def def_grad_e(p,U,T):
    ### deformation gradient of one element
    
    
    ############## input ##############
    # p - points of the mesh
    # U - displacements
    # T - connectivity list
    
    ############## output ##############
    # F - list of class 'deform_grad' (see classes.py)
    
    ###### separate u - horizontal, and v - vertical displacements
    if U.shape[0]==2*p.shape[0]:
        u=U[::2]
        v=U[1::2]
    else:
        u=U[:,0]
        v=U[:,1]
    ###### create function to perform the Lagrange reduction
    def basis_reduction(E):
        ### basis reduction
        if np.linalg.norm(E[:,0])>np.linalg.norm(E[:,1]):
            E = E[:,[1,0]]
        if np.dot(E[:,0],E[:,1])<0:
            E[:,1] = - E[:,1]
        if np.linalg.norm(E[:,1]-E[:,0])<np.linalg.norm(E[:,1]):
            E[:,1]=E[:,1]-E[:,0]
            E = basis_reduction(E);
        return(E)
        
    ### get nodes inside an element
    nodes=T
    ### calculate element area
    A=0.5*np.linalg.det(np.array([[1,1,1],p[nodes,0],p[nodes,1]]))
    ### inverse transform of a current element to a reference one
    invJ=0.5/A*np.array([[(p[nodes[2],1]-p[nodes[0],1]),-(p[nodes[2],0]-p[nodes[0],0])], [-(p[nodes[1],1]-p[nodes[0],1]),(p[nodes[1],0]-p[nodes[0],0])]])
    ### matrix of dispacement gradients   
    def_u=np.array([[u[nodes[1]]-u[nodes[0]],u[nodes[2]]-u[nodes[0]]],[v[nodes[1]]-v[nodes[0]],v[nodes[2]]-v[nodes[0]]]])
    ### calculate the deformation gradient
    F_temp=np.eye(2)+def_u.dot(invJ)
    ### the matrix of derivatives comes from differentiation with respect
    ### to coordinates of the basic triangular by columns
    derF_1=np.array([-1.0*(invJ[0,0]+invJ[1,0]),0,-1.0*(invJ[0,1]+invJ[1,1]),0]) ### dF/du_1
    derF_2=np.array([0,-1.0*(invJ[0,0]+invJ[1,0]),0,-1.0*(invJ[0,1]+invJ[1,1])]) ### dF/dv_1    
    derF_3=np.array([invJ[0,0],0,invJ[0,1],0]) ### dF/du_2
    derF_4=np.array([0,invJ[0,0],0,invJ[0,1]]) ### dF/dv_2  
    derF_5=np.array([invJ[1,0],0,invJ[1,1],0]) ### dF/du_3
    derF_6=np.array([0,invJ[1,0],0,invJ[1,1]]) ### dF/dv_3
    ### save the final result
    dF=np.array([derF_1,derF_2,derF_3,derF_4,derF_5,derF_6]).T
    
    
    ### perform the Lagrange reduction
    F_r=basis_reduction(np.copy(F_temp))
    m=np.linalg.inv(F_temp).dot(F_r)
    F=deform_grad(F_temp,dF,A,F_r,m)
  
    return(F)  
    
def bound_cond(geom,bc_type='F',s=None,u0=None,v0=None,bulk_load=None):
    ############## input ##############
    # geom - geometry of type geom_gen (see classes.py)
    # bc_type - 'F' or any other string meaning:
    ### F - fixed boundaries follow the deformation gradient F
    ### or displacements are prescribed by u0 and v0 and can be periodic
    
    # bulk_load - loading the bulk node of type bulk_node(see classes.py)
    
    ############## output ##############
    # BCs_val - boundary conditions of class 'BCs' (see classes.py)
    # bulk_load_val - loading the bulk node of class 'bulk_node' (see classes.py)
    
#    # prepare the arrays
#    if geom.top.shape[0]<geom.top.shape[0]:
#        geom.top=geom.top.T
#    if geom.bottom.shape[0]<geom.bottom.shape[0]:
#        geom.bottom=geom.bottom.T
#    if geom.left.shape[0]<geom.left.shape[0]:
#        geom.left=geom.left.T
#    if geom.right.shape[0]<geom.right.shape[0]:
#        geom.right=geom.right.T

    if bc_type == 'F':
        # deformation gradient to load
        F_load=np.array([[1,s],[0,1]])
        # new points
        p_new=geom.p.dot(F_load.T)
        
        # HORIZONTAL displacements of boundaries
        u0_top=p_new[geom.top,0]-geom.p[geom.top,0]
        u0_bottom=p_new[geom.bottom,0]-geom.p[geom.bottom,0]
        u0_left=p_new[geom.left,0]-geom.p[geom.left,0]
        u0_right=p_new[geom.right,0]-geom.p[geom.right,0]
        
        # VERTICAL displacements of boundaries
        v0_top=p_new[geom.top,1]-geom.p[geom.top,1]
        v0_bottom=p_new[geom.bottom,1]-geom.p[geom.bottom,1]
        v0_left=p_new[geom.left,1]-geom.p[geom.left,1]
        v0_right=p_new[geom.right,1]-geom.p[geom.right,1]
        
        u0=displ_bc(u0_top,u0_bottom,u0_left,u0_right)
        v0=displ_bc(v0_top,v0_bottom,v0_left,v0_right)
    
    
    # all indices of degrees of freedom for boundary nodes
    ind_bound=np.sort(np.concatenate((2*geom.bound,2*geom.bound+1),axis=0))
    
    # check if periodic conditions are imposed

    ### HORIZONTAL displacements on top and bottom
    if isinstance(u0.top, str) or isinstance(u0.bottom, str):
        ind_bound=np.setdiff1d(ind_bound, 2*geom.top)
    ### HORIZONTAL displacements on left and right
    if isinstance(u0.left, str) or isinstance(u0.right, str):
        ind_bound=np.setdiff1d(ind_bound, 2*geom.left)
    ### VERTICAL displacements on top and bottom
    if isinstance(v0.top, str) or isinstance(v0.bottom, str):
        ind_bound=np.setdiff1d(ind_bound, 2*geom.top+1)
    ### VERTICAL displacements on left and right
    if isinstance(v0.left, str) or isinstance(v0.right, str):
        ind_bound=np.setdiff1d(ind_bound, 2*geom.left+1)
    # free nodes
    ind_free=np.setdiff1d(np.arange(2*geom.p.shape[0]),ind_bound)
    
    # define the boundary conditions
    BCs_val = BCs(geom.top,geom.bottom,geom.left,geom.right,u0,v0)
    # define the bulk nodes
    if bulk_load is None:
        bulk_load_val=bulk_node(np.empty((0,1),int),0,0,ind_free)
    else:
        bulk_load_val=bulk_node(bulk_load.node,bulk_load.u0,bulk_load.v0,ind_free)
    
    return(BCs_val,bulk_load_val)
    
def energy_density(en_par,C):
    ############## input ##############
    # en_par - energy parameters of type en_parameters (see classes.py)
    # C - metric (Cauchy-Green) tensor after the Lagrange reduction
    
    ############## output ##############
    # E - energy density with its derivative with respect to C of class 'en_density' (see classes.py)
    if en_par.en_type == 'kirchhoff':
        # define the components of C
        C11=C[0,0]
        C22=C[1,1]
        C12=C[0,1]
        
        # normalise by the determinant
        C_mod=C/np.sqrt(C11*C22-C12**2)
        # calculate strains in Voigts notations
        eps=np.array([0.5*(C_mod[0,0]-1.),0.5*(C_mod[1,1]-1.),2*0.5*C_mod[0,1]]);
        # components of the Hooke's stiffness tensor
        C_h11=en_par.C[0,0];
        C_h22=en_par.C[1,1];
        C_h33=en_par.C[2,2];
        C_h12=en_par.C[0,1];
        C_h13=en_par.C[0,2];
        C_h23=en_par.C[1,2];
        
        # energy density
        W_temp=0.5*eps.T*en_par.C*eps
        # volumetric part W_v=K*(detC-log(detC)), K - bulk modulus
        W_v_temp=en_par.K*((C11*C22-C12**2)-np.log((C11*C22-C12**2)))
        
        # derivatives (from symbolic differentiation)
        
        dW_dC11 = -0.5*C12*C22*(C11*C22 - C12**2)**(-1.5)*(0.5*C12*C_h33*(C11*C22 - C12**2)**(-0.5) + C_h13*(0.25*C11*(C11*C22 - C12**2)**(-0.5) - 0.25) + C_h23*(0.25*C22*(C11*C22 - C12**2)**(-0.5) - 0.25)) + C12*(C11*C22 - C12**2)**(-0.5)*(-0.25*C12*C22*C_h33*(C11*C22 - C12**2)**(-1.5) - 0.125*C22**2*C_h23*(C11*C22 - C12**2)**(-1.5) + C_h13*(-0.125*C11*C22*(C11*C22 - C12**2)**(-1.5) + 0.25*(C11*C22 - C12**2)**(-0.5))) - 0.25*C22**2*(C11*C22 - C12**2)**(-1.5)*(0.5*C12*C_h23*(C11*C22 - C12**2)**(-0.5) + C_h12*(0.25*C11*(C11*C22 - C12**2)**(-0.5) - 0.25) + C_h22*(0.25*C22*(C11*C22 - C12**2)**(-0.5) - 0.25)) + (0.5*C11*(C11*C22 - C12**2)**(-0.5) - 0.5)*(-0.25*C12*C22*C_h13*(C11*C22 - C12**2)**(-1.5) - 0.125*C22**2*C_h12*(C11*C22 - C12**2)**(-1.5) + C_h11*(-0.125*C11*C22*(C11*C22 - C12**2)**(-1.5) + 0.25*(C11*C22 - C12**2)**(-0.5))) + (0.5*C22*(C11*C22 - C12**2)**(-0.5) - 0.5)*(-0.25*C12*C22*C_h23*(C11*C22 - C12**2)**(-1.5) - 0.125*C22**2*C_h22*(C11*C22 - C12**2)**(-1.5) + C_h12*(-0.125*C11*C22*(C11*C22 - C12**2)**(-1.5) + 0.25*(C11*C22 - C12**2)**(-0.5))) + (-0.25*C11*C22*(C11*C22 - C12**2)**(-1.5) + 0.5*(C11*C22 - C12**2)**(-0.5))*(0.5*C12*C_h13*(C11*C22 - C12**2)**(-0.5) + C_h11*(0.25*C11*(C11*C22 - C12**2)**(-0.5) - 0.25) + C_h12*(0.25*C22*(C11*C22 - C12**2)**(-0.5) - 0.25))
        dW_dC22 = -0.25*C11**2*(C11*C22 - C12**2)**(-1.5)*(0.5*C12*C_h13*(C11*C22 - C12**2)**(-0.5) + C_h11*(0.25*C11*(C11*C22 - C12**2)**(-0.5) - 0.25) + C_h12*(0.25*C22*(C11*C22 - C12**2)**(-0.5) - 0.25)) - 0.5*C11*C12*(C11*C22 - C12**2)**(-1.5)*(0.5*C12*C_h33*(C11*C22 - C12**2)**(-0.5) + C_h13*(0.25*C11*(C11*C22 - C12**2)**(-0.5) - 0.25) + C_h23*(0.25*C22*(C11*C22 - C12**2)**(-0.5) - 0.25)) + C12*(C11*C22 - C12**2)**(-0.5)*(-0.125*C11**2*C_h13*(C11*C22 - C12**2)**(-1.5) - 0.25*C11*C12*C_h33*(C11*C22 - C12**2)**(-1.5) + C_h23*(-0.125*C11*C22*(C11*C22 - C12**2)**(-1.5) + 0.25*(C11*C22 - C12**2)**(-0.5))) + (0.5*C11*(C11*C22 - C12**2)**(-0.5) - 0.5)*(-0.125*C11**2*C_h11*(C11*C22 - C12**2)**(-1.5) - 0.25*C11*C12*C_h13*(C11*C22 - C12**2)**(-1.5) + C_h12*(-0.125*C11*C22*(C11*C22 - C12**2)**(-1.5) + 0.25*(C11*C22 - C12**2)**(-0.5))) + (0.5*C22*(C11*C22 - C12**2)**(-0.5) - 0.5)*(-0.125*C11**2*C_h12*(C11*C22 - C12**2)**(-1.5) - 0.25*C11*C12*C_h23*(C11*C22 - C12**2)**(-1.5) + C_h22*(-0.125*C11*C22*(C11*C22 - C12**2)**(-1.5) + 0.25*(C11*C22 - C12**2)**(-0.5))) + (-0.25*C11*C22*(C11*C22 - C12**2)**(-1.5) + 0.5*(C11*C22 - C12**2)**(-0.5))*(0.5*C12*C_h23*(C11*C22 - C12**2)**(-0.5) + C_h12*(0.25*C11*(C11*C22 - C12**2)**(-0.5) - 0.25) + C_h22*(0.25*C22*(C11*C22 - C12**2)**(-0.5) - 0.25))
        dW_dC12 = 0.5*C11*C12*(C11*C22 - C12**2)**(-1.5)*(0.5*C12*C_h13*(C11*C22 - C12**2)**(-0.5) + C_h11*(0.25*C11*(C11*C22 - C12**2)**(-0.5) - 0.25) + C_h12*(0.25*C22*(C11*C22 - C12**2)**(-0.5) - 0.25)) + 1.0*C12**2*(C11*C22 - C12**2)**(-1.5)*(0.5*C12*C_h33*(C11*C22 - C12**2)**(-0.5) + C_h13*(0.25*C11*(C11*C22 - C12**2)**(-0.5) - 0.25) + C_h23*(0.25*C22*(C11*C22 - C12**2)**(-0.5) - 0.25)) + 0.5*C12*C22*(C11*C22 - C12**2)**(-1.5)*(0.5*C12*C_h23*(C11*C22 - C12**2)**(-0.5) + C_h12*(0.25*C11*(C11*C22 - C12**2)**(-0.5) - 0.25) + C_h22*(0.25*C22*(C11*C22 - C12**2)**(-0.5) - 0.25)) + C12*(C11*C22 - C12**2)**(-0.5)*(0.25*C11*C12*C_h13*(C11*C22 - C12**2)**(-1.5) + 0.5*C12**2*C_h33*(C11*C22 - C12**2)**(-1.5) + 0.25*C12*C22*C_h23*(C11*C22 - C12**2)**(-1.5) + 0.5*C_h33*(C11*C22 - C12**2)**(-0.5)) + (C11*C22 - C12**2)**(-0.5)*(0.5*C12*C_h33*(C11*C22 - C12**2)**(-0.5) + C_h13*(0.25*C11*(C11*C22 - C12**2)**(-0.5) - 0.25) + C_h23*(0.25*C22*(C11*C22 - C12**2)**(-0.5) - 0.25)) + (0.5*C11*(C11*C22 - C12**2)**(-0.5) - 0.5)*(0.25*C11*C12*C_h11*(C11*C22 - C12**2)**(-1.5) + 0.5*C12**2*C_h13*(C11*C22 - C12**2)**(-1.5) + 0.25*C12*C22*C_h12*(C11*C22 - C12**2)**(-1.5) + 0.5*C_h13*(C11*C22 - C12**2)**(-0.5)) + (0.5*C22*(C11*C22 - C12**2)**(-0.5) - 0.5)*(0.25*C11*C12*C_h12*(C11*C22 - C12**2)**(-1.5) + 0.5*C12**2*C_h23*(C11*C22 - C12**2)**(-1.5) + 0.25*C12*C22*C_h22*(C11*C22 - C12**2)**(-1.5) + 0.5*C_h23*(C11*C22 - C12**2)**(-0.5))
        
        
        # derivative of the volumetric part
        dW_vol_dC11 = en_par.K * (C22 + C22 / (C12 ** 2 - C11 * C22))
        dW_vol_dC22 = en_par.K * (C11 + C11 / (C12 ** 2 - C11 * C22))
        dW_vol_dC12 = en_par.K * (-2 * C12 - (2 * C12) / (C12 ** 2 - C11 * C22))
    elif en_par.en_type == 'poly':
        
        # beta is a parameter to define the symmetry
        if en_par.C == 'sq':
            beta=-0.25
        elif en_par.C == 'hex':
            beta=4
        
        # define the components of C
        C11=C[0,0]
        C22=C[1,1]
        C12=C[0,1]
        
        # normalise by the determinant
        C_mod=C/np.sqrt(C11*C22-C12**2)
        
        I_1=1/3*(C_mod[0,0]+C_mod[1,1]-C_mod[0,1]);
        I_2=1/4*(C_mod[0,0]-C_mod[1,1])**2+1/12*(C_mod[0,0]+C_mod[1,1]-4*C_mod[0,1])**2;
        I_3=(C_mod[0,0]-C_mod[1,1])**2*(C_mod[0,0]+C_mod[1,1]-4*C_mod[0,1])-1/9*(C_mod[0,0]+C_mod[1,1]-4*C_mod[0,1])**3;
        # set the functions psi_1 and psi_2
        psi_1=I_1**4*I_2-41/99*I_2**3+7/66*I_1*I_2*I_3+1/1056*I_3**2;
        psi_2=4/11*I_2**3+I_1**3*I_3-8/11*I_1*I_2*I_3+17/528*I_3**2;
        
        # energy density
        W_temp=beta*psi_1+psi_2;
        # volumetric part W_v=K*(detC-log(detC)), K - bulk modulus
        W_v_temp=en_par.K*((C11*C22-C12**2.)-np.log((C11*C22-C12**2.)))
        
        # derivatives (from symbolic differentiation)
        dW_dC11 = beta*(((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))*(-1.0*C11*C22*(C11*C22 - C12**2)**(-1.5) + C22**2*(C11*C22 - C12**2)**(-1.5) + 2*(C11*C22 - C12**2)**(-0.5))/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))*(-1.0*C11*C22*(C11*C22 - C12**2)**(-1.5) + 4.0*C12*C22*(C11*C22 - C12**2)**(-1.5) - 1.0*C22**2*(C11*C22 - C12**2)**(-1.5) + 2*(C11*C22 - C12**2)**(-0.5))/12)*((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5)) - (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**3/9)*(7*C11*(C11*C22 - C12**2)**(-0.5)/198 - 7*C12*(C11*C22 - C12**2)**(-0.5)/198 + 7*C22*(C11*C22 - C12**2)**(-0.5)/198) + ((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))*(-1.0*C11*C22*(C11*C22 - C12**2)**(-1.5) + C22**2*(C11*C22 - C12**2)**(-1.5) + 2*(C11*C22 - C12**2)**(-0.5))/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))*(-1.0*C11*C22*(C11*C22 - C12**2)**(-1.5) + 4.0*C12*C22*(C11*C22 - C12**2)**(-1.5) - 1.0*C22**2*(C11*C22 - C12**2)**(-1.5) + 2*(C11*C22 - C12**2)**(-0.5))/12)*(C11*(C11*C22 - C12**2)**(-0.5)/3 - C12*(C11*C22 - C12**2)**(-0.5)/3 + C22*(C11*C22 - C12**2)**(-0.5)/3)**4 - 41*(3*(C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))*(-1.0*C11*C22*(C11*C22 - C12**2)**(-1.5) + C22**2*(C11*C22 - C12**2)**(-1.5) + 2*(C11*C22 - C12**2)**(-0.5))/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))*(-1.0*C11*C22*(C11*C22 - C12**2)**(-1.5) + 4.0*C12*C22*(C11*C22 - C12**2)**(-1.5) - 1.0*C22**2*(C11*C22 - C12**2)**(-1.5) + 2*(C11*C22 - C12**2)**(-0.5))/4)*((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2/12)**2/99 + ((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5)) - (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**3/9)*((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2/12)*(-0.0176767676767677*C11*C22*(C11*C22 - C12**2)**(-1.5) + 0.0176767676767677*C12*C22*(C11*C22 - C12**2)**(-1.5) - 0.0176767676767677*C22**2*(C11*C22 - C12**2)**(-1.5) + 7*(C11*C22 - C12**2)**(-0.5)/198) + ((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5)) - (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**3/9)*(2*(C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(-0.5*C11*C22*(C11*C22 - C12**2)**(-1.5) + 2.0*C12*C22*(C11*C22 - C12**2)**(-1.5) - 0.5*C22**2*(C11*C22 - C12**2)**(-1.5) + (C11*C22 - C12**2)**(-0.5)) + 2*(C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))*(-1.0*C11*C22*(C11*C22 - C12**2)**(-1.5) + C22**2*(C11*C22 - C12**2)**(-1.5) + 2*(C11*C22 - C12**2)**(-0.5)) - 2*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2*(-1.5*C11*C22*(C11*C22 - C12**2)**(-1.5) + 6.0*C12*C22*(C11*C22 - C12**2)**(-1.5) - 1.5*C22**2*(C11*C22 - C12**2)**(-1.5) + 3*(C11*C22 - C12**2)**(-0.5))/9)/1056 + ((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2/12)*(7*C11*(C11*C22 - C12**2)**(-0.5)/198 - 7*C12*(C11*C22 - C12**2)**(-0.5)/198 + 7*C22*(C11*C22 - C12**2)**(-0.5)/198)*((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(-0.5*C11*C22*(C11*C22 - C12**2)**(-1.5) + 2.0*C12*C22*(C11*C22 - C12**2)**(-1.5) - 0.5*C22**2*(C11*C22 - C12**2)**(-1.5) + (C11*C22 - C12**2)**(-0.5)) + (C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))*(-1.0*C11*C22*(C11*C22 - C12**2)**(-1.5) + C22**2*(C11*C22 - C12**2)**(-1.5) + 2*(C11*C22 - C12**2)**(-0.5)) - (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2*(-1.5*C11*C22*(C11*C22 - C12**2)**(-1.5) + 6.0*C12*C22*(C11*C22 - C12**2)**(-1.5) - 1.5*C22**2*(C11*C22 - C12**2)**(-1.5) + 3*(C11*C22 - C12**2)**(-0.5))/9) + ((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2/12)*(C11*(C11*C22 - C12**2)**(-0.5)/3 - C12*(C11*C22 - C12**2)**(-0.5)/3 + C22*(C11*C22 - C12**2)**(-0.5)/3)**3*(-0.666666666666667*C11*C22*(C11*C22 - C12**2)**(-1.5) + 0.666666666666667*C12*C22*(C11*C22 - C12**2)**(-1.5) - 0.666666666666667*C22**2*(C11*C22 - C12**2)**(-1.5) + 4*(C11*C22 - C12**2)**(-0.5)/3)) + ((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))*(-1.0*C11*C22*(C11*C22 - C12**2)**(-1.5) + C22**2*(C11*C22 - C12**2)**(-1.5) + 2*(C11*C22 - C12**2)**(-0.5))/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))*(-1.0*C11*C22*(C11*C22 - C12**2)**(-1.5) + 4.0*C12*C22*(C11*C22 - C12**2)**(-1.5) - 1.0*C22**2*(C11*C22 - C12**2)**(-1.5) + 2*(C11*C22 - C12**2)**(-0.5))/12)*(-(C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5)) + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**3/9)*(8*C11*(C11*C22 - C12**2)**(-0.5)/33 - 8*C12*(C11*C22 - C12**2)**(-0.5)/33 + 8*C22*(C11*C22 - C12**2)**(-0.5)/33) + 4*(3*(C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))*(-1.0*C11*C22*(C11*C22 - C12**2)**(-1.5) + C22**2*(C11*C22 - C12**2)**(-1.5) + 2*(C11*C22 - C12**2)**(-0.5))/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))*(-1.0*C11*C22*(C11*C22 - C12**2)**(-1.5) + 4.0*C12*C22*(C11*C22 - C12**2)**(-1.5) - 1.0*C22**2*(C11*C22 - C12**2)**(-1.5) + 2*(C11*C22 - C12**2)**(-0.5))/4)*((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2/12)**2/11 + (-(C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5)) + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**3/9)*((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2/12)*(-0.121212121212121*C11*C22*(C11*C22 - C12**2)**(-1.5) + 0.121212121212121*C12*C22*(C11*C22 - C12**2)**(-1.5) - 0.121212121212121*C22**2*(C11*C22 - C12**2)**(-1.5) + 8*(C11*C22 - C12**2)**(-0.5)/33) + ((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5)) - (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**3/9)*(C11*(C11*C22 - C12**2)**(-0.5)/3 - C12*(C11*C22 - C12**2)**(-0.5)/3 + C22*(C11*C22 - C12**2)**(-0.5)/3)**2*(-0.5*C11*C22*(C11*C22 - C12**2)**(-1.5) + 0.5*C12*C22*(C11*C22 - C12**2)**(-1.5) - 0.5*C22**2*(C11*C22 - C12**2)**(-1.5) + (C11*C22 - C12**2)**(-0.5)) + 17*((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5)) - (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**3/9)*(2*(C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(-0.5*C11*C22*(C11*C22 - C12**2)**(-1.5) + 2.0*C12*C22*(C11*C22 - C12**2)**(-1.5) - 0.5*C22**2*(C11*C22 - C12**2)**(-1.5) + (C11*C22 - C12**2)**(-0.5)) + 2*(C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))*(-1.0*C11*C22*(C11*C22 - C12**2)**(-1.5) + C22**2*(C11*C22 - C12**2)**(-1.5) + 2*(C11*C22 - C12**2)**(-0.5)) - 2*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2*(-1.5*C11*C22*(C11*C22 - C12**2)**(-1.5) + 6.0*C12*C22*(C11*C22 - C12**2)**(-1.5) - 1.5*C22**2*(C11*C22 - C12**2)**(-1.5) + 3*(C11*C22 - C12**2)**(-0.5))/9)/528 + ((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2/12)*(8*C11*(C11*C22 - C12**2)**(-0.5)/33 - 8*C12*(C11*C22 - C12**2)**(-0.5)/33 + 8*C22*(C11*C22 - C12**2)**(-0.5)/33)*(-(C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(-0.5*C11*C22*(C11*C22 - C12**2)**(-1.5) + 2.0*C12*C22*(C11*C22 - C12**2)**(-1.5) - 0.5*C22**2*(C11*C22 - C12**2)**(-1.5) + (C11*C22 - C12**2)**(-0.5)) - (C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))*(-1.0*C11*C22*(C11*C22 - C12**2)**(-1.5) + C22**2*(C11*C22 - C12**2)**(-1.5) + 2*(C11*C22 - C12**2)**(-0.5)) + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2*(-1.5*C11*C22*(C11*C22 - C12**2)**(-1.5) + 6.0*C12*C22*(C11*C22 - C12**2)**(-1.5) - 1.5*C22**2*(C11*C22 - C12**2)**(-1.5) + 3*(C11*C22 - C12**2)**(-0.5))/9) + (C11*(C11*C22 - C12**2)**(-0.5)/3 - C12*(C11*C22 - C12**2)**(-0.5)/3 + C22*(C11*C22 - C12**2)**(-0.5)/3)**3*((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(-0.5*C11*C22*(C11*C22 - C12**2)**(-1.5) + 2.0*C12*C22*(C11*C22 - C12**2)**(-1.5) - 0.5*C22**2*(C11*C22 - C12**2)**(-1.5) + (C11*C22 - C12**2)**(-0.5)) + (C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))*(-1.0*C11*C22*(C11*C22 - C12**2)**(-1.5) + C22**2*(C11*C22 - C12**2)**(-1.5) + 2*(C11*C22 - C12**2)**(-0.5)) - (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2*(-1.5*C11*C22*(C11*C22 - C12**2)**(-1.5) + 6.0*C12*C22*(C11*C22 - C12**2)**(-1.5) - 1.5*C22**2*(C11*C22 - C12**2)**(-1.5) + 3*(C11*C22 - C12**2)**(-0.5))/9)
        dW_dC22 = beta*(((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))*(-1.0*C11**2*(C11*C22 - C12**2)**(-1.5) + C11*C22*(C11*C22 - C12**2)**(-1.5) - 2*(C11*C22 - C12**2)**(-0.5))/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))*(-1.0*C11**2*(C11*C22 - C12**2)**(-1.5) + 4.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 1.0*C11*C22*(C11*C22 - C12**2)**(-1.5) + 2*(C11*C22 - C12**2)**(-0.5))/12)*((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5)) - (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**3/9)*(7*C11*(C11*C22 - C12**2)**(-0.5)/198 - 7*C12*(C11*C22 - C12**2)**(-0.5)/198 + 7*C22*(C11*C22 - C12**2)**(-0.5)/198) + ((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))*(-1.0*C11**2*(C11*C22 - C12**2)**(-1.5) + C11*C22*(C11*C22 - C12**2)**(-1.5) - 2*(C11*C22 - C12**2)**(-0.5))/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))*(-1.0*C11**2*(C11*C22 - C12**2)**(-1.5) + 4.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 1.0*C11*C22*(C11*C22 - C12**2)**(-1.5) + 2*(C11*C22 - C12**2)**(-0.5))/12)*(C11*(C11*C22 - C12**2)**(-0.5)/3 - C12*(C11*C22 - C12**2)**(-0.5)/3 + C22*(C11*C22 - C12**2)**(-0.5)/3)**4 - 41*(3*(C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))*(-1.0*C11**2*(C11*C22 - C12**2)**(-1.5) + C11*C22*(C11*C22 - C12**2)**(-1.5) - 2*(C11*C22 - C12**2)**(-0.5))/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))*(-1.0*C11**2*(C11*C22 - C12**2)**(-1.5) + 4.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 1.0*C11*C22*(C11*C22 - C12**2)**(-1.5) + 2*(C11*C22 - C12**2)**(-0.5))/4)*((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2/12)**2/99 + ((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5)) - (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**3/9)*((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2/12)*(-0.0176767676767677*C11**2*(C11*C22 - C12**2)**(-1.5) + 0.0176767676767677*C11*C12*(C11*C22 - C12**2)**(-1.5) - 0.0176767676767677*C11*C22*(C11*C22 - C12**2)**(-1.5) + 7*(C11*C22 - C12**2)**(-0.5)/198) + ((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5)) - (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**3/9)*(2*(C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(-0.5*C11**2*(C11*C22 - C12**2)**(-1.5) + 2.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 0.5*C11*C22*(C11*C22 - C12**2)**(-1.5) + (C11*C22 - C12**2)**(-0.5)) + 2*(C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))*(-1.0*C11**2*(C11*C22 - C12**2)**(-1.5) + C11*C22*(C11*C22 - C12**2)**(-1.5) - 2*(C11*C22 - C12**2)**(-0.5)) - 2*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2*(-1.5*C11**2*(C11*C22 - C12**2)**(-1.5) + 6.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 1.5*C11*C22*(C11*C22 - C12**2)**(-1.5) + 3*(C11*C22 - C12**2)**(-0.5))/9)/1056 + ((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2/12)*(7*C11*(C11*C22 - C12**2)**(-0.5)/198 - 7*C12*(C11*C22 - C12**2)**(-0.5)/198 + 7*C22*(C11*C22 - C12**2)**(-0.5)/198)*((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(-0.5*C11**2*(C11*C22 - C12**2)**(-1.5) + 2.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 0.5*C11*C22*(C11*C22 - C12**2)**(-1.5) + (C11*C22 - C12**2)**(-0.5)) + (C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))*(-1.0*C11**2*(C11*C22 - C12**2)**(-1.5) + C11*C22*(C11*C22 - C12**2)**(-1.5) - 2*(C11*C22 - C12**2)**(-0.5)) - (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2*(-1.5*C11**2*(C11*C22 - C12**2)**(-1.5) + 6.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 1.5*C11*C22*(C11*C22 - C12**2)**(-1.5) + 3*(C11*C22 - C12**2)**(-0.5))/9) + ((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2/12)*(C11*(C11*C22 - C12**2)**(-0.5)/3 - C12*(C11*C22 - C12**2)**(-0.5)/3 + C22*(C11*C22 - C12**2)**(-0.5)/3)**3*(-0.666666666666667*C11**2*(C11*C22 - C12**2)**(-1.5) + 0.666666666666667*C11*C12*(C11*C22 - C12**2)**(-1.5) - 0.666666666666667*C11*C22*(C11*C22 - C12**2)**(-1.5) + 4*(C11*C22 - C12**2)**(-0.5)/3)) + ((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))*(-1.0*C11**2*(C11*C22 - C12**2)**(-1.5) + C11*C22*(C11*C22 - C12**2)**(-1.5) - 2*(C11*C22 - C12**2)**(-0.5))/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))*(-1.0*C11**2*(C11*C22 - C12**2)**(-1.5) + 4.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 1.0*C11*C22*(C11*C22 - C12**2)**(-1.5) + 2*(C11*C22 - C12**2)**(-0.5))/12)*(-(C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5)) + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**3/9)*(8*C11*(C11*C22 - C12**2)**(-0.5)/33 - 8*C12*(C11*C22 - C12**2)**(-0.5)/33 + 8*C22*(C11*C22 - C12**2)**(-0.5)/33) + 4*(3*(C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))*(-1.0*C11**2*(C11*C22 - C12**2)**(-1.5) + C11*C22*(C11*C22 - C12**2)**(-1.5) - 2*(C11*C22 - C12**2)**(-0.5))/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))*(-1.0*C11**2*(C11*C22 - C12**2)**(-1.5) + 4.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 1.0*C11*C22*(C11*C22 - C12**2)**(-1.5) + 2*(C11*C22 - C12**2)**(-0.5))/4)*((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2/12)**2/11 + (-(C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5)) + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**3/9)*((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2/12)*(-0.121212121212121*C11**2*(C11*C22 - C12**2)**(-1.5) + 0.121212121212121*C11*C12*(C11*C22 - C12**2)**(-1.5) - 0.121212121212121*C11*C22*(C11*C22 - C12**2)**(-1.5) + 8*(C11*C22 - C12**2)**(-0.5)/33) + ((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5)) - (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**3/9)*(C11*(C11*C22 - C12**2)**(-0.5)/3 - C12*(C11*C22 - C12**2)**(-0.5)/3 + C22*(C11*C22 - C12**2)**(-0.5)/3)**2*(-0.5*C11**2*(C11*C22 - C12**2)**(-1.5) + 0.5*C11*C12*(C11*C22 - C12**2)**(-1.5) - 0.5*C11*C22*(C11*C22 - C12**2)**(-1.5) + (C11*C22 - C12**2)**(-0.5)) + 17*((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5)) - (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**3/9)*(2*(C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(-0.5*C11**2*(C11*C22 - C12**2)**(-1.5) + 2.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 0.5*C11*C22*(C11*C22 - C12**2)**(-1.5) + (C11*C22 - C12**2)**(-0.5)) + 2*(C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))*(-1.0*C11**2*(C11*C22 - C12**2)**(-1.5) + C11*C22*(C11*C22 - C12**2)**(-1.5) - 2*(C11*C22 - C12**2)**(-0.5)) - 2*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2*(-1.5*C11**2*(C11*C22 - C12**2)**(-1.5) + 6.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 1.5*C11*C22*(C11*C22 - C12**2)**(-1.5) + 3*(C11*C22 - C12**2)**(-0.5))/9)/528 + ((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2/12)*(8*C11*(C11*C22 - C12**2)**(-0.5)/33 - 8*C12*(C11*C22 - C12**2)**(-0.5)/33 + 8*C22*(C11*C22 - C12**2)**(-0.5)/33)*(-(C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(-0.5*C11**2*(C11*C22 - C12**2)**(-1.5) + 2.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 0.5*C11*C22*(C11*C22 - C12**2)**(-1.5) + (C11*C22 - C12**2)**(-0.5)) - (C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))*(-1.0*C11**2*(C11*C22 - C12**2)**(-1.5) + C11*C22*(C11*C22 - C12**2)**(-1.5) - 2*(C11*C22 - C12**2)**(-0.5)) + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2*(-1.5*C11**2*(C11*C22 - C12**2)**(-1.5) + 6.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 1.5*C11*C22*(C11*C22 - C12**2)**(-1.5) + 3*(C11*C22 - C12**2)**(-0.5))/9) + (C11*(C11*C22 - C12**2)**(-0.5)/3 - C12*(C11*C22 - C12**2)**(-0.5)/3 + C22*(C11*C22 - C12**2)**(-0.5)/3)**3*((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(-0.5*C11**2*(C11*C22 - C12**2)**(-1.5) + 2.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 0.5*C11*C22*(C11*C22 - C12**2)**(-1.5) + (C11*C22 - C12**2)**(-0.5)) + (C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))*(-1.0*C11**2*(C11*C22 - C12**2)**(-1.5) + C11*C22*(C11*C22 - C12**2)**(-1.5) - 2*(C11*C22 - C12**2)**(-0.5)) - (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2*(-1.5*C11**2*(C11*C22 - C12**2)**(-1.5) + 6.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 1.5*C11*C22*(C11*C22 - C12**2)**(-1.5) + 3*(C11*C22 - C12**2)**(-0.5))/9)
        dW_dC12 = beta*(((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))*(2.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 2.0*C12*C22*(C11*C22 - C12**2)**(-1.5))/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))*(2.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 8.0*C12**2*(C11*C22 - C12**2)**(-1.5) + 2.0*C12*C22*(C11*C22 - C12**2)**(-1.5) - 8*(C11*C22 - C12**2)**(-0.5))/12)*((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5)) - (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**3/9)*(7*C11*(C11*C22 - C12**2)**(-0.5)/198 - 7*C12*(C11*C22 - C12**2)**(-0.5)/198 + 7*C22*(C11*C22 - C12**2)**(-0.5)/198) + ((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))*(2.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 2.0*C12*C22*(C11*C22 - C12**2)**(-1.5))/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))*(2.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 8.0*C12**2*(C11*C22 - C12**2)**(-1.5) + 2.0*C12*C22*(C11*C22 - C12**2)**(-1.5) - 8*(C11*C22 - C12**2)**(-0.5))/12)*(C11*(C11*C22 - C12**2)**(-0.5)/3 - C12*(C11*C22 - C12**2)**(-0.5)/3 + C22*(C11*C22 - C12**2)**(-0.5)/3)**4 - 41*(3*(C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))*(2.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 2.0*C12*C22*(C11*C22 - C12**2)**(-1.5))/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))*(2.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 8.0*C12**2*(C11*C22 - C12**2)**(-1.5) + 2.0*C12*C22*(C11*C22 - C12**2)**(-1.5) - 8*(C11*C22 - C12**2)**(-0.5))/4)*((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2/12)**2/99 + ((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5)) - (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**3/9)*((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2/12)*(0.0353535353535354*C11*C12*(C11*C22 - C12**2)**(-1.5) - 0.0353535353535354*C12**2*(C11*C22 - C12**2)**(-1.5) + 0.0353535353535354*C12*C22*(C11*C22 - C12**2)**(-1.5) - 7*(C11*C22 - C12**2)**(-0.5)/198) + ((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5)) - (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**3/9)*(2*(C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(1.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 4.0*C12**2*(C11*C22 - C12**2)**(-1.5) + 1.0*C12*C22*(C11*C22 - C12**2)**(-1.5) - 4*(C11*C22 - C12**2)**(-0.5)) + 2*(C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))*(2.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 2.0*C12*C22*(C11*C22 - C12**2)**(-1.5))*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5)) - 2*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2*(3.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 12.0*C12**2*(C11*C22 - C12**2)**(-1.5) + 3.0*C12*C22*(C11*C22 - C12**2)**(-1.5) - 12*(C11*C22 - C12**2)**(-0.5))/9)/1056 + ((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2/12)*(7*C11*(C11*C22 - C12**2)**(-0.5)/198 - 7*C12*(C11*C22 - C12**2)**(-0.5)/198 + 7*C22*(C11*C22 - C12**2)**(-0.5)/198)*((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(1.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 4.0*C12**2*(C11*C22 - C12**2)**(-1.5) + 1.0*C12*C22*(C11*C22 - C12**2)**(-1.5) - 4*(C11*C22 - C12**2)**(-0.5)) + (C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))*(2.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 2.0*C12*C22*(C11*C22 - C12**2)**(-1.5))*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5)) - (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2*(3.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 12.0*C12**2*(C11*C22 - C12**2)**(-1.5) + 3.0*C12*C22*(C11*C22 - C12**2)**(-1.5) - 12*(C11*C22 - C12**2)**(-0.5))/9) + ((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2/12)*(C11*(C11*C22 - C12**2)**(-0.5)/3 - C12*(C11*C22 - C12**2)**(-0.5)/3 + C22*(C11*C22 - C12**2)**(-0.5)/3)**3*(1.33333333333333*C11*C12*(C11*C22 - C12**2)**(-1.5) - 1.33333333333333*C12**2*(C11*C22 - C12**2)**(-1.5) + 1.33333333333333*C12*C22*(C11*C22 - C12**2)**(-1.5) - 4*(C11*C22 - C12**2)**(-0.5)/3)) + ((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))*(2.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 2.0*C12*C22*(C11*C22 - C12**2)**(-1.5))/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))*(2.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 8.0*C12**2*(C11*C22 - C12**2)**(-1.5) + 2.0*C12*C22*(C11*C22 - C12**2)**(-1.5) - 8*(C11*C22 - C12**2)**(-0.5))/12)*(-(C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5)) + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**3/9)*(8*C11*(C11*C22 - C12**2)**(-0.5)/33 - 8*C12*(C11*C22 - C12**2)**(-0.5)/33 + 8*C22*(C11*C22 - C12**2)**(-0.5)/33) + 4*(3*(C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))*(2.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 2.0*C12*C22*(C11*C22 - C12**2)**(-1.5))/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))*(2.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 8.0*C12**2*(C11*C22 - C12**2)**(-1.5) + 2.0*C12*C22*(C11*C22 - C12**2)**(-1.5) - 8*(C11*C22 - C12**2)**(-0.5))/4)*((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2/12)**2/11 + (-(C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5)) + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**3/9)*((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2/12)*(0.242424242424242*C11*C12*(C11*C22 - C12**2)**(-1.5) - 0.242424242424242*C12**2*(C11*C22 - C12**2)**(-1.5) + 0.242424242424242*C12*C22*(C11*C22 - C12**2)**(-1.5) - 8*(C11*C22 - C12**2)**(-0.5)/33) + ((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5)) - (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**3/9)*(C11*(C11*C22 - C12**2)**(-0.5)/3 - C12*(C11*C22 - C12**2)**(-0.5)/3 + C22*(C11*C22 - C12**2)**(-0.5)/3)**2*(C11*C12*(C11*C22 - C12**2)**(-1.5) - 1.0*C12**2*(C11*C22 - C12**2)**(-1.5) + C12*C22*(C11*C22 - C12**2)**(-1.5) - (C11*C22 - C12**2)**(-0.5)) + 17*((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5)) - (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**3/9)*(2*(C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(1.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 4.0*C12**2*(C11*C22 - C12**2)**(-1.5) + 1.0*C12*C22*(C11*C22 - C12**2)**(-1.5) - 4*(C11*C22 - C12**2)**(-0.5)) + 2*(C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))*(2.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 2.0*C12*C22*(C11*C22 - C12**2)**(-1.5))*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5)) - 2*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2*(3.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 12.0*C12**2*(C11*C22 - C12**2)**(-1.5) + 3.0*C12*C22*(C11*C22 - C12**2)**(-1.5) - 12*(C11*C22 - C12**2)**(-0.5))/9)/528 + ((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2/4 + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2/12)*(8*C11*(C11*C22 - C12**2)**(-0.5)/33 - 8*C12*(C11*C22 - C12**2)**(-0.5)/33 + 8*C22*(C11*C22 - C12**2)**(-0.5)/33)*(-(C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(1.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 4.0*C12**2*(C11*C22 - C12**2)**(-1.5) + 1.0*C12*C22*(C11*C22 - C12**2)**(-1.5) - 4*(C11*C22 - C12**2)**(-0.5)) - (C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))*(2.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 2.0*C12*C22*(C11*C22 - C12**2)**(-1.5))*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5)) + (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2*(3.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 12.0*C12**2*(C11*C22 - C12**2)**(-1.5) + 3.0*C12*C22*(C11*C22 - C12**2)**(-1.5) - 12*(C11*C22 - C12**2)**(-0.5))/9) + (C11*(C11*C22 - C12**2)**(-0.5)/3 - C12*(C11*C22 - C12**2)**(-0.5)/3 + C22*(C11*C22 - C12**2)**(-0.5)/3)**3*((C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))**2*(1.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 4.0*C12**2*(C11*C22 - C12**2)**(-1.5) + 1.0*C12*C22*(C11*C22 - C12**2)**(-1.5) - 4*(C11*C22 - C12**2)**(-0.5)) + (C11*(C11*C22 - C12**2)**(-0.5) - C22*(C11*C22 - C12**2)**(-0.5))*(2.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 2.0*C12*C22*(C11*C22 - C12**2)**(-1.5))*(C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5)) - (C11*(C11*C22 - C12**2)**(-0.5) - 4*C12*(C11*C22 - C12**2)**(-0.5) + C22*(C11*C22 - C12**2)**(-0.5))**2*(3.0*C11*C12*(C11*C22 - C12**2)**(-1.5) - 12.0*C12**2*(C11*C22 - C12**2)**(-1.5) + 3.0*C12*C22*(C11*C22 - C12**2)**(-1.5) - 12*(C11*C22 - C12**2)**(-0.5))/9)    
        
        # derivative of the volumetric part
        dW_vol_dC11 = en_par.K * (C22 + C22 / (C12 ** 2 - C11 * C22))
        dW_vol_dC22 = en_par.K * (C11 + C11 / (C12 ** 2 - C11 * C22))
        dW_vol_dC12 = en_par.K * (-2 * C12 - (2 * C12) / (C12 ** 2 - C11 * C22))
    # the total energy density
    W_tot=W_temp+W_v_temp
    # matrix of derivatives    
    J=np.array([[dW_dC11+dW_vol_dC11,0.5*(dW_dC12+dW_vol_dC12)],[0.5*(dW_dC12+dW_vol_dC12),dW_dC22+dW_vol_dC22]])
    return(en_density(W_tot,J))


def global_energy(en_par,p,U,T):
    ############## input ##############
    # en_par - energy parameters of type en_parameters (see classes.py)
    # p - points of the mesh
    # U - displacements
    # T - connectivity list
    
    ############## output ##############
    # E,dE - global energy and gradient with respect to U

    # derivatives for each elements, every row is [dE/du_1 dE/dv_1 dE/du_2 dE/dv_2 dE/du_3 dE/dv_3]
    # value of the energy
    E=0;
    #  its derivative
    dE = np.zeros((2*p.shape[0],))
    # derivatives for each element
    dE_T=np.zeros((6,))
    for i in range(T.shape[0]):
        # call the deformation gradient
        F_i = def_grad_e(p,U,T[i,:]);
        # calculate the metric tensor
        C=F_i.F_r.T.dot(F_i.F_r)
        # call the energy within an element
        W = energy_density(en_par,C)
        # accumulate the total energy
        E=E+F_i.A*W.W;
        # the 1st Piola-Kirchhof stress
        P=F_i.F.dot(F_i.m.dot(W.dW.dot(F_i.m.T)))   
        ### make an array
        P_vec=np.array([P[0,0],P[1,0],P[0,1],P[1,1]])
        # E_T gradient for each node with respect to [u1 v1 u2 v2 ...]
        dE_T=2*F_i.A*P_vec.dot(F_i.dF)
        # dE_T=(2*F_i.A*P.reshape((1,4)).dot(F_i.dF))[0]
        # accumulate derivative at each point
        dE[2*T[i,:]]=dE[2*T[i,:]]+dE_T[0::2]
        dE[2*T[i,:]+1]=dE[2*T[i,:]+1]+dE_T[1::2]
        # for ii in range(T.shape[1]):
        #     dE[2*T[i,ii]]=dE[2*T[i,ii]]+dE_T[2*ii]
        #     dE[2*T[i,ii]+1]=dE[2*T[i,ii]+1]+dE_T[2*ii+1]
        
    
#    for i in range(p.shape[0]):
#        # find the node in all elements
#        ind = np.where(T==i)
#        for j in range(len(ind[0])):
#            # sum the results over each element
#            dE[2*i]=dE[2*i]+dE_T[ind[0][j],2*ind[1][j]];
#            dE[2*i+1]=dE[2*i+1]+dE_T[ind[0][j],2*ind[1][j]+1];
    return(E,dE)
    
def global_energy_constr(en_par,p,W,T,BCs_val,bulk_val):
    ############## input ##############
    # en_par - energy parameters of type 'en_parameters' (see classes.py)
    # p - points of the mesh
    # W - free displacements
    # T - connectivity list
    # BCs_val - boundary conditions of type 'BCs' (see classes.py)
    # bulk_val - fixed bulk nodes + free nodes of type 'bulk_node' (see classes.py)
    
    ############## output ##############
    # E, dE - energy value and its gradient
    
    # define the unknown displacements
    U=np.zeros(2*p.shape[0])
    U[bulk_val.free]=W;
    
    # define the known displacements
    # TOP or BOTTOM - HORIZONTAL
    if not(isinstance(BCs_val.u0.top, str)) and not(isinstance(BCs_val.u0.bottom, str)):
        U[2*BCs_val.top]=BCs_val.u0.top;
        U[2*BCs_val.bottom]=BCs_val.u0.bottom;
    else:
        #if periodic condition is used
        U[2*BCs_val.bottom]=U[2*BCs_val.top]
    # TOP or BOTTOM - VERTICAL
    if not(isinstance(BCs_val.v0.top, str)) and not(isinstance(BCs_val.v0.bottom, str)):
        U[2*BCs_val.top+1]=BCs_val.v0.top;
        U[2*BCs_val.bottom+1]=BCs_val.v0.bottom;
    else:
        #if periodic condition is used
        U[2*BCs_val.bottom+1]=U[2*BCs_val.top+1]
    # LEFT or RIGHT - HORIZONTAL
    if not(isinstance(BCs_val.u0.left, str)) and not(isinstance(BCs_val.u0.right, str)):
        U[2*BCs_val.left]=BCs_val.u0.left;
        U[2*BCs_val.right]=BCs_val.u0.right;
    else:
        #if periodic condition is used
        U[2*BCs_val.left]=U[2*BCs_val.right]
    # LEFT or RIGHT - VERTICAL
    if not(isinstance(BCs_val.v0.left, str)) and not(isinstance(BCs_val.v0.right, str)):
        U[2*BCs_val.left+1]=BCs_val.v0.left;
        U[2*BCs_val.right+1]=BCs_val.v0.right;
    else:
        #if periodic condition is used
        U[2*BCs_val.left+1]=U[2*BCs_val.right+1]
    # fixed node
    U[2*bulk_val.node]=bulk_val.u0; # HORIZONTAL
    U[2*bulk_val.node+1]=bulk_val.v0;   # VERTICAL
    
    E_tot,dE_tot=global_energy(en_par,p,U,T)
    
    E=E_tot
    dE=dE_tot[bulk_val.free]

    ############ additional terms due to periodicity ############
    # TOP or BOTTOM - HORIZONTAL
    if isinstance(BCs_val.u0.top, str) or isinstance(BCs_val.u0.bottom, str):
        ia=np.in1d(bulk_val.free,2*BCs_val.top)
        dE[ia]=dE[ia]+dE_tot[2*BCs_val.bottom]
    # TOP or BOTTOM - VERTICAL
    if isinstance(BCs_val.v0.top, str) or isinstance(BCs_val.v0.bottom, str):
        ia=np.in1d(bulk_val.free,2*BCs_val.top+1)
        dE[ia]=dE[ia]+dE_tot[2*BCs_val.bottom+1]
    # LEFT or RIGHT - HORIZONTAL
    if isinstance(BCs_val.u0.left, str) or isinstance(BCs_val.u0.right, str):
        ia=np.in1d(bulk_val.free,2*BCs_val.left)
        dE[ia]=dE[ia]+dE_tot[2*BCs_val.right]
    # LEFT or RIGHT - VERTICAL
    if isinstance(BCs_val.v0.left, str) or isinstance(BCs_val.v0.right, str):
        ia=np.in1d(bulk_val.free,2*BCs_val.left+1)
        dE[ia]=dE[ia]+dE_tot[2*BCs_val.right+1]
    return E,dE
def stress_value(en_par,F):
    ############## input ##############
    # en_par - energy parameters of type "en_parameters" (see classes.py)
    # F - deformation gradient of type "deform_grad" (see classes.py)
    
    ############## output ##############
    # s - element stresses of a class 'stress_element' (see classes.py)
    

    # calculate the metric tensor
    C=F.F_r.T.dot(F.F_r)
    # call the energy within an element
    W = energy_density(en_par,C)
        
    # the 1st Piola-Kirchhof stress
    P=F.F.dot(F.m.dot(W.dW.dot(F.m.T)))
        
    # sigma within element
    sigma_T=2*F.F_r.dot(W.dW.dot(F.F_r.T))/np.linalg.det(F.F)
    
    # the 2nd Piola-Kirchhof stress
    S_T=2*F.m.dot(W.dW.dot(F.m.T));
    
    # make the structure and return its values
    s=stress_element(sigma_T,P,S_T)
    return(s)
def energy_stress(en_par,p,U,T):
    ############## input ##############
    # en_par - energy parameters of type en_parameters (see classes.py)
    # p - points of the mesh
    # U - displacements
    # T - connectivity list
    
    ############## output ##############
    # E - global energy of class 'gl_energy' (see classes.py)
    
#    # call the deformation gradient
#    F = def_grad(p,U,T);

    # derivatives for each elements, every row is [dE/du_1 dE/dv_1 dE/du_2 dE/dv_2 dE/du_3 dE/dv_3]
    dE_T=np.zeros((6,));
    # energy gradient for each 
    E_T=np.zeros(T.shape[0]);
    # value of the energy
    E_val=0;
    # dE_T gradient for each node with respect to [u1 v1 u2 v2 ...]
    dE = np.zeros(2*p.shape[0])
    
    # values for stresses in each element
    sigma_el=np.zeros((T.shape[0],3));
    piola_1_el=np.zeros((T.shape[0],4));
    piola_2_el=np.zeros((T.shape[0],3));
    
    for i in range(T.shape[0]):
#        # calculate the metric tensor
#        C=F[i].F_r.T.dot(F[i].F_r)
#        # call the energy within an element
#        W = energy_density(en_par,C)
#        #save the energy of each element
#        E_T[i]=F[i].A*W.W;
#        # accumulate the total energy
#        E_val=E_val+E_T[i];
#        
#        # the 1st Piola-Kirchhof stress
#        P=F[i].F.dot(F[i].m.dot(W.dW.dot(F[i].m.T)))
#        
#        # derivative within an element
#        dE_T[i,:]=2*F[i].A*P.reshape((1,4)).dot(F[i].dF);
#        
#        # sigma within element
#        sigma_T=F[i].F_r.dot(W.dW.dot(F[i].F_r.T))/np.linalg.det(F[i].F)
        
        # call the deformation gradient
        F_i = def_grad_e(p,U,T[i,:]);
        
        # calculate the metric tensor
        C=F_i.F_r.T.dot(F_i.F_r)
        # call the energy within an element
        W = energy_density(en_par,C)
        
        #save the energy of each element
        E_T[i]=F_i.A*W.W;
        
        # accumulate the total energy
        E_val=E_val+E_T[i];
        
        # the 1st Piola-Kirchhof stress
        P=F_i.F.dot(F_i.m.dot(W.dW.dot(F_i.m.T)))
        ### make an array
        P_vec=np.array([P[0,0],P[1,0],P[0,1],P[1,1]])
        # dE_T gradient for each node with respect to [u1 v1 u2 v2 ...]
        dE_T=2*F_i.A*P_vec.dot(F_i.dF)
        # accumulate derivative at each point
        dE[2*T[i,:]]=dE[2*T[i,:]]+dE_T[0::2]
        dE[2*T[i,:]+1]=dE[2*T[i,:]+1]+dE_T[1::2]
        
        # sigma within element
        sigma_T=F_i.F_r.dot(W.dW.dot(F_i.F_r.T))/np.linalg.det(F_i.F)
        
        # the 2nd Piola-Kirchhof stress
        S_T=2*W.dW;
        
        # save stresses for each element
        sigma_el[i,:]=[sigma_T[0,0],sigma_T[1,1],sigma_T[0,1]]
        piola_1_el[i,:]=[P[0,0],P[1,0],P[0,1],P[1,1]]
        piola_2_el[i,:]=[S_T[0,0],S_T[1,1],S_T[0,1]]
    # total stresses        
    sigma_tot=np.sum(sigma_el,axis=0)
    piola_1_tot=np.sum(piola_1_el,axis=0)
    piola_2_tot=np.sum(piola_2_el,axis=0)
    # make one variable for output
    stress_E=stress(sigma_el,piola_1_el,piola_2_el, sigma_tot,piola_1_tot,piola_2_tot)
    
    # for i in range(p.shape[0]):
    #     # find the node in all elements
    #     ind = np.where(T==i)
    #     for j in range(len(ind[0])):
    #         # sum the results over each element
    #         dE[2*i]=dE[2*i]+dE_T[ind[0][j],2*ind[1][j]];
    #         dE[2*i+1]=dE[2*i+1]+dE_T[ind[0][j],2*ind[1][j]+1];
    return(gl_energy(E_val, dE, E_T, stress_E, U))
def total_displ(p,W,T,BCs_val,bulk_val):
    ############## input ##############
    # p - points of the mesh
    # W - free displacements
    # T - connectivity list
    # BCs - boundary conditions
    # bulk - fixed bulk nodes + free nodes
    
    ############## output ##############
    # U - displacements of all nodes
    
    # define the unknown displacements
    U=np.zeros(2*p.shape[0])
    U[bulk_val.free]=W;
    
    # define the known displacements
    # TOP or BOTTOM - HORIZONTAL
    if not(isinstance(BCs_val.u0.top, str)) and not(isinstance(BCs_val.u0.bottom, str)):
        U[2*BCs_val.top]=BCs_val.u0.top;
        U[2*BCs_val.bottom]=BCs_val.u0.bottom;
    else:
        #if periodic condition is used
        U[2*BCs_val.bottom]=U[2*BCs_val.top]
    # TOP or BOTTOM - VERTICAL
    if not(isinstance(BCs_val.v0.top, str)) and not(isinstance(BCs_val.v0.bottom, str)):
        U[2*BCs_val.top+1]=BCs_val.v0.top;
        U[2*BCs_val.bottom+1]=BCs_val.v0.bottom;
    else:
        #if periodic condition is used
        U[2*BCs_val.bottom+1]=U[2*BCs_val.top+1]
    # LEFT or RIGHT - HORIZONTAL
    if not(isinstance(BCs_val.u0.left, str)) and not(isinstance(BCs_val.u0.right, str)):
        U[2*BCs_val.left]=BCs_val.u0.left;
        U[2*BCs_val.right]=BCs_val.u0.right;
    else:
        #if periodic condition is used
        U[2*BCs_val.left]=U[2*BCs_val.right]
    # LEFT or RIGHT - VERTICAL
    if not(isinstance(BCs_val.v0.left, str)) and not(isinstance(BCs_val.v0.right, str)):
        U[2*BCs_val.left+1]=BCs_val.v0.left;
        U[2*BCs_val.right+1]=BCs_val.v0.right;
    else:
        #if periodic condition is used
        U[2*BCs_val.left+1]=U[2*BCs_val.right+1]
    # fixed node
    U[2*bulk_val.node]=bulk_val.u0; # HORIZONTAL
    U[2*bulk_val.node+1]=bulk_val.v0;   # VERTICAL
    
    return U